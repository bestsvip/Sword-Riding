<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰‘æŒ‡ç”»ç¬¦</title>
    <!-- ç§»é™¤äº†ä¸å†éœ€è¦çš„ camera_utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root { --paper-w: 330px; --paper-h: 580px; }
        
        /* ä¿®æ”¹1: ç§»é™¤ body çš„ flex å¸ƒå±€ï¼Œé˜²æ­¢å› éæ³• DOM å…ƒç´ å¯¼è‡´çš„å¸ƒå±€åç§» */
        body { 
            margin: 0; 
            background: #111; 
            height: 100vh; 
            overflow: hidden; 
            font-family: "KaiTi", serif; 
            position: relative; /* ä¸ºç»å¯¹å®šä½å­å…ƒç´ æä¾›å‚è€ƒ */
        }

        /* ä¿®æ”¹2: ä½¿ç”¨ç»å¯¹å®šä½å¼ºåˆ¶å±…ä¸­ */
        #game-area { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: var(--paper-w); 
            height: var(--paper-h); 
            perspective: 1000px; 
            /* ä½¿ç”¨ translate æŠµæ¶ˆè‡ªèº«çš„ 50% å®½é«˜ï¼Œå®ç°å®Œç¾å±…ä¸­ */
            transform: translate(-50%, -50%); 
            /* æ³¨æ„ï¼šå› ä¸ºè¿™é‡Œä½¿ç”¨äº† transformï¼Œå¦‚æœè¦å¯¹ #game-area æœ¬èº«åšåŠ¨ç”»ï¼Œéœ€è¦åµŒå¥—ä¸€å±‚å®¹å™¨ï¼Œ
               ä½†åŸæœ¬çš„åŠ¨ç”»æ˜¯ä½œç”¨åœ¨ #paper-layer å­å…ƒç´ ä¸Šçš„ï¼Œæ‰€ä»¥è¿™é‡Œå®‰å…¨ã€‚ */
            z-index: 5;
        }

        /* 1. ç¬¦çº¸å±‚ */
        #paper-layer {
            position: absolute; inset: 0; z-index: 1;
            background: #f0c239;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.2'/%3E%3C/svg%3E");
            border: 2px solid #d4a017;
            -webkit-mask-image: linear-gradient(to top, transparent 45%, black 55%);
            mask-image: linear-gradient(to top, transparent 45%, black 55%);
            -webkit-mask-size: 100% 250%;
            mask-size: 100% 250%;
            -webkit-mask-position: 0% 0%;
            mask-position: 0% 0%;
        }

        /* 2. æ¨¡æ¿å±‚ */
        #template-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
            display: flex; justify-content: center; align-items: center;
        }
        .tpl-item { position: absolute; width: 80%; height: 80%; transition: all 0.4s ease; opacity: 0; }
        .tpl-item svg { width: 100%; height: 100%; fill: none; stroke: rgba(255, 255, 255, 0.25); stroke-width: 8; stroke-linecap: round; stroke-linejoin: round; }
        .tpl-center { transform: translateX(0) scale(1); opacity: 1; z-index: 10; }
        .tpl-left   { transform: translateX(-120%) scale(0.8); opacity: 0.3; }
        .tpl-right  { transform: translateX(120%) scale(0.8); opacity: 0.3; }
        .tpl-hidden { transform: scale(0.5); opacity: 0; }

        /* 3. ç¬”è¿¹ä¸ç²’å­ */
        canvas { position: absolute; inset: 0; pointer-events: none; }
        #ink-canvas { z-index: 3; }
        #particle-canvas { z-index: 4; width: 150%; height: 150%; left: -25%; top: -25%; }

        /* åŠ¨ç”»ç‰¹æ•ˆ */
        .charging-anim {
            animation: shake 0.1s infinite;
            box-shadow: 0 0 30px #ff4444 !important;
            border-color: #ff4444 !important;
        }

        @keyframes shake {
            0% { transform: rotate(0deg) translate(0,0); }
            25% { transform: rotate(0.5deg) translate(1px, 1px); }
            50% { transform: rotate(0deg) translate(0,0); }
            75% { transform: rotate(-0.5deg) translate(-1px, -1px); }
            100% { transform: rotate(0deg) translate(0,0); }
        }

        .burn-anim {
            -webkit-mask-image: linear-gradient(to top, transparent 45%, black 55%);
            mask-image: linear-gradient(to top, transparent 45%, black 55%);
            -webkit-mask-size: 100% 250%;
            mask-size: 100% 250%;
            animation: slowBurn 2.5s cubic-bezier(0.45, 0, 0.55, 1) forwards;
        }

        @keyframes slowBurn {
            0% { -webkit-mask-position: 0% 0%; mask-position: 0% 0%; opacity: 1; }
            100% { -webkit-mask-position: 0% 100%; mask-position: 0% 100%; opacity: 0; }
        }

        /* UI */
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
        #cam-box { position: absolute; bottom: 60px; left: 20px; width: 240px; height: 180px; background: #000; border: 2px solid #444; border-radius: 8px; overflow: hidden; transition: 0.3s; }
        #cam-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
        #cam-overlay { position: absolute; inset: 0; transform: scaleX(-1); }
        
        #status { position: absolute; top: 10px; width: 100%; text-align: center; color: #fff; font-size: 22px; text-shadow: 0 2px 4px #000; transition: color 0.3s; }
        #guide-hint { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; }
        
        #vanish-bar-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 220px; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px;
            opacity: 0; transition: opacity 0.3s;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.3);
        }
        #vanish-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ff8800); border-radius: 4px; transition: width 0.05s linear; }

        #btn-toggle { position: absolute; bottom: 20px; left: 20px; width: 240px;pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #ccc; padding: 5px 10px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="game-area">
        <div id="paper-layer"></div>
        <div id="template-layer">
            <div class="tpl-item" id="tpl-0"></div>
            <div class="tpl-item" id="tpl-1"></div>
            <div class="tpl-item" id="tpl-2"></div>
        </div>
        <canvas id="ink-canvas"></canvas>
        <canvas id="particle-canvas"></canvas>
        <div id="vanish-bar-box"><div id="vanish-fill"></div></div>
    </div>

    <div id="ui-layer">
        <button id="btn-toggle">åˆ‡æ¢: å®æ™¯æ¨¡å¼</button>
        <div id="status">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
        <div id="guide-hint">ğŸ–ï¸ å·¦å³æŒ¥æ‰‹åˆ‡æ¢æ¨¡æ¿<br>âœŒï¸ å‰‘æŒ‡å…¥æ‘„åƒå¤´å†…å¼€å§‹ç”»ç¬¦<br>
            ç”»å®Œåå°†æ‰‹å¿«é€Ÿç§»å‘æ‘„åƒå¤´
        </div>
        <div id="cam-box">
            <video id="cam-video" playsinline></video>
            <canvas id="cam-overlay"></canvas>
        </div>
    </div>

    <script>
        var decreeTime = 0.8

        const TEMPLATES = [
            `<path d="M50,20 L250,20 M150,20 L150,100 M80,120 L220,120 M150,120 L150,200 M100,220 Q150,300 200,220 M150,250 L150,500 M120,400 L180,420 M180,400 L120,420" />`,
            `<path d="M150,30 L150,550 M100,50 L200,50 M100,500 L200,500 M80,150 L220,150 M100,150 Q50,300 100,450 M200,150 Q250,300 200,450 M130,250 L170,250 L170,350 L130,350 Z" />`,
            `<path d="M150,20 L150,560 M120,50 L180,60 M120,100 L180,110 M120,150 L180,160 M100,200 L200,200 M150,200 Q250,300 150,400 Q50,300 150,200 M150,400 L120,550 M150,400 L180,550" />`
        ];

        class TemplateSystem {
            constructor() {
                this.idx = 0;
                this.els = [document.getElementById('tpl-0'), document.getElementById('tpl-1'), document.getElementById('tpl-2')];
                this.els.forEach((el, i) => el.innerHTML = `<svg viewBox="0 0 300 600">${TEMPLATES[i]}</svg>`);
                this.update();
            }
            next() { this.idx = (this.idx + 1) % 3; this.update(); }
            prev() { this.idx = (this.idx - 1 + 3) % 3; this.update(); }
            update() {
                const prev = (this.idx - 1 + 3) % 3;
                const next = (this.idx + 1) % 3;
                this.els.forEach(el => el.className = 'tpl-item tpl-hidden');
                this.els[this.idx].className = 'tpl-item tpl-center';
                this.els[prev].className = 'tpl-item tpl-left';
                this.els[next].className = 'tpl-item tpl-right';
            }
        }

        class RenderSystem {
            constructor() {
                this.inkCanvas = document.getElementById('ink-canvas');
                this.ctx = this.inkCanvas.getContext('2d');
                this.pCanvas = document.getElementById('particle-canvas');
                this.pCtx = this.pCanvas.getContext('2d');
                this.paper = document.getElementById('paper-layer');
                this.tplLayer = document.getElementById('template-layer');
                this.statusEl = document.getElementById('status');
                this.vanishBox = document.getElementById('vanish-bar-box');
                this.vanishFill = document.getElementById('vanish-fill');
                
                this.particles = [];
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#c92a2a';
                this.ctx.lineWidth = 6;

                this.particles = [];
                this.isBurning = false;
                this.burnStartTime = 0;
                this.BURN_DURATION = ( decreeTime + 0.2 )* 1000;

                this.loop();
            }

            resize() {
                const r = this.paper.getBoundingClientRect();
                this.inkCanvas.width = r.width; this.inkCanvas.height = r.height;
                this.pCanvas.width = r.width * decreeTime; this.pCanvas.height = r.height * decreeTime;
            }

            drawSegment(p1, p2) {
                if (!p1 || !p2) return;
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.quadraticCurveTo((p1.x + p2.x)/2, (p1.y + p2.y)/2, p2.x, p2.y);
                this.ctx.stroke();
            }

            setChargingState(active) {
                if (active) this.paper.classList.add('charging-anim');
                else this.paper.classList.remove('charging-anim');
            }

            triggerBurn() {
                this.setChargingState(false);
                this.paper.classList.add('burn-anim');
                this.inkCanvas.classList.add('burn-anim');
                this.tplLayer.classList.add('burn-anim');
                this.spawnAshParticles();
            }

            resetBurn() {
                [this.paper, this.inkCanvas, this.tplLayer].forEach(el => {
                    el.classList.remove('burn-anim');
                    void el.offsetWidth;
                    el.style.opacity = 1;
                });
                this.ctx.clearRect(0, 0, this.inkCanvas.width, this.inkCanvas.height);
            }

            spawnAshParticles() {
                let spawnedCount = 0;
                const totalParticles = 600;
                const interval = setInterval(() => {
                    for(let i=0; i<8; i++) {
                        this.particles.push({
                            x: Math.random() * this.pCanvas.width,
                            y: this.pCanvas.height + Math.random() * 50, 
                            vx: (Math.random() - 0.5) * 3,
                            vy: -Math.random() * 3 - 2,
                            life: 1.0,
                            size: Math.random() * 8 + 2,
                            color: Math.random() > 0.6 ? '#c92a2a' : (Math.random() > 0.4 ? '#ff8800' : '#111')
                        });
                    }
                    spawnedCount += 8;
                    if(spawnedCount >= totalParticles) clearInterval(interval);
                }, 30); 
                this.animateParticles();
            }

            animateParticles() {
                if(this.particles.length === 0) return;
                this.pCtx.clearRect(0, 0, this.pCanvas.width, this.pCanvas.height);
                for(let i=0; i<this.particles.length; i++) {
                    let p = this.particles[i];
                    p.x += p.vx + Math.sin(p.y * 0.01) * 1; 
                    p.y += p.vy; 
                    p.life -= 0.01; 
                    p.size *= 0.98;
                    this.pCtx.save();
                    this.pCtx.globalAlpha = p.life;
                    this.pCtx.fillStyle = p.color;
                    this.pCtx.beginPath();
                    this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.pCtx.fill();
                    this.pCtx.restore();
                    if(p.life <= 0) { this.particles.splice(i, 1); i--; }
                }
                requestAnimationFrame(() => this.animateParticles());
            }

            updateVanishBar(pct) {
                if(pct > 0) {
                    this.vanishBox.style.opacity = 1;
                    this.vanishFill.style.width = `${pct * 100}%`;
                } else {
                    this.vanishBox.style.opacity = 0;
                    this.vanishFill.style.width = '0%';
                }
            }
            
            setStatus(text, color='#fff') { this.statusEl.innerText = text; this.statusEl.style.color = color; }
            loop() {
                this.pCtx.clearRect(0, 0, this.pCanvas.width, this.pCanvas.height);

                // 1. å¤„ç†ç‡ƒçƒ§
                if (this.isBurning) {
                    const elapsed = Date.now() - this.burnStartTime;
                    const progress = Math.min(1, elapsed / this.BURN_DURATION);
                    
                    // è®¡ç®—ç‡ƒçƒ§çº¿çš„ä½ç½® (ä»ä¸‹ 100% å¾€ä¸Š 0%)
                    // Mask logic: transparent at top, black at bottom. 
                    // Gradient stop moves from 100% (all black) to 0% (all transparent)
                    
                    const burnYPct = 100 - (progress * 100); 
                    
                    // åº”ç”¨ Mask
                    const maskCSS = `linear-gradient(to top, black ${burnYPct}%, transparent ${burnYPct + 10}%)`;
                    this.burnLayers.forEach(el => {
                        el.style.webkitMaskImage = maskCSS;
                        el.style.maskImage = maskCSS;
                    });

                    // 2. åœ¨ç‡ƒçƒ§çº¿ä¸Šç”Ÿæˆç²’å­
                    // ç‡ƒçƒ§çº¿åœ¨ Canvas ä¸­çš„å®é™… Y åæ ‡ (æ³¨æ„ç²’å­Canvasæœ‰åç§»)
                    // GameArea é«˜åº¦ 580. ç²’å­ Canvas top -100.
                    // ç‡ƒçƒ§çº¿ Y (ç›¸å¯¹äº GameArea) = 580 * (burnYPct / 100)
                    const gameAreaH = this.inkCanvas.height;
                    const burnLineY_Game = gameAreaH * (burnYPct / 100);
                    
                    // æ˜ å°„åˆ°ç²’å­ Canvas åæ ‡ (åŠ åç§» 100)
                    const spawnY = burnLineY_Game + 100;

                    // æ¯ä¸€å¸§ç”Ÿæˆä¸€æ’ç²’å­
                    if (progress < 1.0) {
                        for(let i=0; i<4; i++) {
                            this.particles.push({
                                x: Math.random() * this.pCanvas.width,
                                y: spawnY + (Math.random() * 20 - 10), // åœ¨çº¿ä¸Šæµ®åŠ¨
                                vx: (Math.random() - 0.5) * 2, // å·¦å³å¾®é£˜
                                vy: -Math.random() * 2 - 1, // å‘ä¸Šé£˜
                                life: 1.0,
                                size: Math.random() * 6 + 2,
                                color: Math.random() > 0.5 ? '#222' : '#ff4400' // é»‘ç°æˆ–ç«æ˜Ÿ
                            });
                        }
                    } else {
                        // çƒ§å®Œäº†ï¼Œç­‰å¾…ç²’å­æ¶ˆæ•£åé‡ç½®
                        if (this.particles.length === 0) {
                           // åŠ¨ç”»å½»åº•ç»“æŸ
                        }
                    }
                }

                // 3. æ›´æ–°ç²’å­
                for (let i = 0; i < this.particles.length; i++) {
                    let p = this.particles[i];
                    p.x += p.vx + Math.sin(p.y * 0.05) * 0.5;
                    p.y += p.vy;
                    p.life -= 0.01;
                    p.size *= 0.98;

                    this.pCtx.save();
                    this.pCtx.globalAlpha = p.life;
                    this.pCtx.fillStyle = p.color;
                    this.pCtx.beginPath();
                    this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.pCtx.fill();
                    this.pCtx.restore();

                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        i--;
                    }
                }

                requestAnimationFrame(() => this.loop());
            }
        }
        
        class GestureBrain {
            constructor(renderer, tplSystem) {
                this.r = renderer;
                this.tpl = tplSystem;
                this.state = 'IDLE'; 
                this.drawStartTime = 0;
                this.lastPos = null;
                
                this.vanishStartTime = 0;
                this.VANISH_TRIGGER_TIME = decreeTime * 1000; 

                this.palmHistory = [];
                this.swipeCooldown = false;
            }

            dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

            isSwordFinger(lm) {
                const wrist = lm[0];
                const ext = (t, p) => this.dist(t, wrist) > this.dist(p, wrist) * 1.1;
                const fold = (t, p) => this.dist(t, wrist) < this.dist(p, wrist) * 1.2;
                return ext(lm[8], lm[6]) && ext(lm[12], lm[10]) && fold(lm[16], lm[14]) && fold(lm[20], lm[18]);
            }

            detectSwipe(lm) {
                if (this.swipeCooldown) return;
                const palmX = lm[9].x;
                const now = Date.now();
                this.palmHistory.push({ x: palmX, time: now });
                this.palmHistory = this.palmHistory.filter(h => now - h.time < 300);
                if (this.palmHistory.length < 5) return;
                const dx = this.palmHistory[this.palmHistory.length-1].x - this.palmHistory[0].x;
                if (Math.abs(dx) > 0.2) {
                    if (dx > 0) { this.tpl.prev(); this.r.setStatus("<< ä¸Šä¸€ä¸ª"); }
                    else { this.tpl.next(); this.r.setStatus("ä¸‹ä¸€ä¸ª >>"); }
                    this.swipeCooldown = true; this.palmHistory = [];
                    setTimeout(() => this.swipeCooldown = false, 500);
                }
            }

            processHand(lm) {
                if (this.state === 'WAITING_FOR_VANISH') {
                    this.vanishStartTime = 0;
                    this.r.updateVanishBar(0);
                    this.r.setChargingState(false);
                    this.state = 'DRAWING'; 
                    this.r.setStatus("æ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œç»§ç»­ç»˜åˆ¶...", "#f0c239");
                    this.lastPos = null;
                }
                
                if(this.state === 'COOLDOWN') return;

                const isSword = this.isSwordFinger(lm);
                const tip = lm[8];
                const cX = (1 - tip.x) * this.r.inkCanvas.width;
                const cY = tip.y * this.r.inkCanvas.height;

                if (isSword) {
                    this.palmHistory = [];
                    if (this.state === 'IDLE') {
                        this.state = 'DRAWING';
                        this.drawStartTime = Date.now();
                        this.lastPos = {x: cX, y: cY};
                        this.r.setStatus("ç”»ç¬¦ä¸­...", "#f0c239");
                    } else if (this.state === 'DRAWING') {
                        if (this.lastPos) {
                            this.r.drawSegment(this.lastPos, {x: cX, y: cY});
                        }
                        this.lastPos = {x: cX, y: cY};
                    }
                } else {
                    if (this.state === 'IDLE') this.detectSwipe(lm);
                    else if (this.state === 'DRAWING') {
                        this.lastPos = null; 
                    }
                }
            }

            checkVanishing() {
                if (this.state !== 'DRAWING' && this.state !== 'WAITING_FOR_VANISH') return;

                const now = Date.now();

                if (this.state === 'DRAWING') {
                    this.state = 'WAITING_FOR_VANISH';
                    this.vanishStartTime = now;
                    this.r.setChargingState(true);
                }

                const elapsed = now - this.vanishStartTime;
                const progress = Math.min(1, elapsed / this.VANISH_TRIGGER_TIME);
                
                this.r.updateVanishBar(progress);
                const sec = (decreeTime - elapsed/1000).toFixed(1);
                this.r.setStatus(`æ••ç¬¦è“„åŠ›ä¸­... ${sec}s`, `rgba(255, ${100 + progress*155}, ${100}, 1)`);

                if (elapsed >= this.VANISH_TRIGGER_TIME) {
                    this.triggerFinish();
                }
            }

            triggerFinish() {
                this.state = 'COOLDOWN';
                this.r.updateVanishBar(0);
                this.r.setChargingState(false);
                this.r.setStatus("æ€¥æ€¥å¦‚å¾‹ä»¤ï¼æ••ï¼", "#ff0000");
                this.r.triggerBurn(); 
                
                setTimeout(() => {
                    this.r.resetBurn();
                    this.state = 'IDLE';
                    this.lastPos = null;
                    this.r.setStatus("å‡†å¤‡å°±ç»ª");
                }, 3500); 
            }
        }

        const tpl = new TemplateSystem();
        const render = new RenderSystem();
        const brain = new GestureBrain(render, tpl);
        
        const videoEl = document.getElementById('cam-video');
        const overlayCanvas = document.getElementById('cam-overlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        const camBox = document.getElementById('cam-box');

        let isSkeleton = false;
        document.getElementById('btn-toggle').onclick = function() {
            isSkeleton = !isSkeleton;
            camBox.style.borderColor = isSkeleton ? '#c92a2a' : '#444';
            videoEl.style.opacity = isSkeleton ? 0 : 0.8;
            this.innerText = isSkeleton ? "åˆ‡æ¢: éª¨éª¼æ¨¡å¼" : "åˆ‡æ¢: å®æ™¯æ¨¡å¼";
        };

        function resizeOverlay() { overlayCanvas.width = camBox.offsetWidth; overlayCanvas.height = camBox.offsetHeight; }
        window.addEventListener('resize', resizeOverlay);
        resizeOverlay();

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });

        hands.onResults(results => {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(overlayCtx, lm, HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.4)', lineWidth: 1});
                drawLandmarks(overlayCtx, lm, {color: '#fff', radius: 1});
                
                brain.processHand(lm);
            } else {
                brain.checkVanishing();
            }
        });

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ navigator.mediaDevices æ›¿ä»£ Camera ç±» ---

        async function startCamera() {
            try {
                // è·å–æ‘„åƒå¤´æµ
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user' // ä¼˜å…ˆä½¿ç”¨å‰ç½®æ‘„åƒå¤´
                    },
                    audio: false
                });

                videoEl.srcObject = stream;
                
                // ç­‰å¾…è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆåæ’­æ”¾
                videoEl.onloadedmetadata = () => {
                    videoEl.play();
                    // å¼€å§‹å°†è§†é¢‘å¸§é€å…¥ hands å¤„ç†çš„å¾ªç¯
                    requestAnimationFrame(sendVideoFrame);
                    render.setStatus("ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸å‡ºå‰‘æŒ‡");
                };

            } catch (err) {
                console.error("Camera access error:", err);
                render.setStatus("ç»åœ°å¤©é€š â€” æ— æ³•è®¿é—®æ‘„åƒå¤´", "red");
            }
        }

        async function sendVideoFrame() {
            if (!videoEl.paused && !videoEl.ended) {
                // å°†è§†é¢‘å…ƒç´ å‘é€ç»™ MediaPipe
                await hands.send({image: videoEl});
            }
            requestAnimationFrame(sendVideoFrame);
        }

        // å¯åŠ¨
        startCamera();

    </script>
</body>
</html>
