<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰‘æŒ‡ç”»ç¬¦</title>
    <!-- ç§»é™¤äº†ä¸å†éœ€è¦çš„ camera_utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root { --paper-w: 330px; --paper-h: 580px; }
        
        /* ä¿®æ”¹1: ç§»é™¤ body çš„ flex å¸ƒå±€ï¼Œé˜²æ­¢å› éæ³• DOM å…ƒç´ å¯¼è‡´çš„å¸ƒå±€åç§» */
        body { 
            margin: 0; 
            background: #111; 
            height: 100vh; 
            overflow: hidden; 
            font-family: "KaiTi", serif; 
            position: relative; /* ä¸ºç»å¯¹å®šä½å­å…ƒç´ æä¾›å‚è€ƒ */
        }

        /* ä¿®æ”¹2: ä½¿ç”¨ç»å¯¹å®šä½å¼ºåˆ¶å±…ä¸­ */
        #game-area { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: var(--paper-w); 
            height: var(--paper-h); 
            perspective: 1000px; 
            /* ä½¿ç”¨ translate æŠµæ¶ˆè‡ªèº«çš„ 50% å®½é«˜ï¼Œå®ç°å®Œç¾å±…ä¸­ */
            transform: translate(-50%, -50%); 
            /* æ³¨æ„ï¼šå› ä¸ºè¿™é‡Œä½¿ç”¨äº† transformï¼Œå¦‚æœè¦å¯¹ #game-area æœ¬èº«åšåŠ¨ç”»ï¼Œéœ€è¦åµŒå¥—ä¸€å±‚å®¹å™¨ï¼Œ
               ä½†åŸæœ¬çš„åŠ¨ç”»æ˜¯ä½œç”¨åœ¨ #paper-layer å­å…ƒç´ ä¸Šçš„ï¼Œæ‰€ä»¥è¿™é‡Œå®‰å…¨ã€‚ */
            z-index: 5;
        }

        /* 1. ç¬¦çº¸å±‚ */
        #paper-layer {
            position: absolute; inset: 0; z-index: 1;
            background: #f0c239;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.2'/%3E%3C/svg%3E");
            border: 2px solid #d4a017;
            -webkit-mask-image: linear-gradient(to top, transparent 45%, black 55%);
            mask-image: linear-gradient(to top, transparent 45%, black 55%);
            -webkit-mask-size: 100% 250%;
            mask-size: 100% 250%;
            -webkit-mask-position: 0% 0%;
            mask-position: 0% 0%;
        }

        /* 2. æ¨¡æ¿å±‚ */
        #template-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
            display: flex; justify-content: center; align-items: center;
        }
        .tpl-item { position: absolute; width: 80%; height: 80%; transition: all 0.4s ease; opacity: 0; }
        .tpl-item svg { width: 100%; height: 100%; fill: none; stroke: rgba(255, 255, 255, 0.25); stroke-width: 8; stroke-linecap: round; stroke-linejoin: round; }
        .tpl-center { transform: translateX(0) scale(1); opacity: 1; z-index: 10; }
        .tpl-left   { transform: translateX(-120%) scale(0.8); opacity: 0.3; }
        .tpl-right  { transform: translateX(120%) scale(0.8); opacity: 0.3; }
        .tpl-hidden { transform: scale(0.5); opacity: 0; }

        /* 3. ç¬”è¿¹ä¸ç²’å­ */
        canvas { position: absolute; inset: 0; pointer-events: none; }
        #ink-canvas { z-index: 3; }
        #particle-canvas { z-index: 4; width: 150%; height: 150%; left: -25%; top: -25%; }

        /* åŠ¨ç”»ç‰¹æ•ˆ */
        .charging-anim {
            animation: shake 0.1s infinite;
            box-shadow: 0 0 30px #ff4444 !important;
            border-color: #ff4444 !important;
        }

        @keyframes shake {
            0% { transform: rotate(0deg) translate(0,0); }
            25% { transform: rotate(0.5deg) translate(1px, 1px); }
            50% { transform: rotate(0deg) translate(0,0); }
            75% { transform: rotate(-0.5deg) translate(-1px, -1px); }
            100% { transform: rotate(0deg) translate(0,0); }
        }

        .burn-anim {
            -webkit-mask-image: linear-gradient(to top, transparent 45%, black 55%);
            mask-image: linear-gradient(to top, transparent 45%, black 55%);
            -webkit-mask-size: 100% 250%;
            mask-size: 100% 250%;
            animation: slowBurn 2.5s cubic-bezier(0.45, 0, 0.55, 1) forwards;
        }

        @keyframes slowBurn {
            0% { -webkit-mask-position: 0% 0%; mask-position: 0% 0%; opacity: 1; }
            100% { -webkit-mask-position: 0% 100%; mask-position: 0% 100%; opacity: 0; }
        }

        /* UI */
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
        /* --- ä¿®æ”¹é‡ç‚¹ 1ï¼šCSS å¸ƒå±€è‡ªé€‚åº” --- */
        #cam-box { 
            position: absolute; 
            bottom: 60px; 
            left: 20px; 
            width: 240px; /* å›ºå®šå®½åº¦ï¼Œé«˜åº¦è‡ªé€‚åº” */
            height: auto; 
            background: #000; 
            border: 2px solid #444; 
            border-radius: 8px; 
            overflow: hidden; 
            transition: border-color 0.3s;
            /* Flex å¸ƒå±€ä¿è¯å†…éƒ¨å…ƒç´ å¯¹é½ */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cam-video { 
            width: 100%; 
            height: auto; 
            display: block; /* æ¶ˆé™¤åº•éƒ¨ç©ºéš™ */
            transform: scaleX(-1); 
            opacity: 0.8; 
        }

        #cam-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            transform: scaleX(-1); 
            /* object-fit æ•ˆæœç”± canvas åˆ†è¾¨ç‡åŒ¹é…å®ç° */
        }        
        #status { position: absolute; top: 10px; width: 100%; text-align: center; color: #fff; font-size: 22px; text-shadow: 0 2px 4px #000; transition: color 0.3s; }
        #guide-hint { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; }
        
        #vanish-bar-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 220px; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px;
            opacity: 0; transition: opacity 0.3s;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.3);
        }
        #vanish-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ff8800); border-radius: 4px; transition: width 0.05s linear; }

        #btn-toggle { position: absolute; bottom: 20px; left: 20px; width: 240px;pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #ccc; padding: 5px 10px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="game-area">
        <div id="paper-layer"></div>
        <div id="template-layer">
            <div class="tpl-item" id="tpl-0"></div>
            <div class="tpl-item" id="tpl-1"></div>
            <div class="tpl-item" id="tpl-2"></div>
        </div>
        <canvas id="ink-canvas"></canvas>
        <canvas id="particle-canvas"></canvas>
        <div id="vanish-bar-box"><div id="vanish-fill"></div></div>
    </div>

    <div id="ui-layer">
        <button id="btn-toggle">åˆ‡æ¢: å®æ™¯æ¨¡å¼</button>
        <div id="status">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
        <div id="guide-hint">ğŸ–ï¸ å·¦å³æŒ¥æ‰‹åˆ‡æ¢æ¨¡æ¿<br>âœŒï¸ å‰‘æŒ‡å…¥æ‘„åƒå¤´å†…å¼€å§‹ç”»ç¬¦<br>
            ç”»å®Œåå°†æ‰‹å¿«é€Ÿç§»å‘æ‘„åƒå¤´
        </div>
        <div id="cam-box">
            <video id="cam-video" playsinline></video>
            <canvas id="cam-overlay"></canvas>
        </div>
    </div>

    <script>
        var decreeTime = 0.8

        const TEMPLATES = [
            `<path d="M50,20 L250,20 M150,20 L150,100 M80,120 L220,120 M150,120 L150,200 M100,220 Q150,300 200,220 M150,250 L150,500 M120,400 L180,420 M180,400 L120,420" />`,
            `<path d="M150,30 L150,550 M100,50 L200,50 M100,500 L200,500 M80,150 L220,150 M100,150 Q50,300 100,450 M200,150 Q250,300 200,450 M130,250 L170,250 L170,350 L130,350 Z" />`,
            `<path d="M150,20 L150,560 M120,50 L180,60 M120,100 L180,110 M120,150 L180,160 M100,200 L200,200 M150,200 Q250,300 150,400 Q50,300 150,200 M150,400 L120,550 M150,400 L180,550" />`
        ];

        class TemplateSystem {
            constructor() {
                this.idx = 0;
                this.els = [document.getElementById('tpl-0'), document.getElementById('tpl-1'), document.getElementById('tpl-2')];
                this.els.forEach((el, i) => el.innerHTML = `<svg viewBox="0 0 300 600">${TEMPLATES[i]}</svg>`);
                this.update();
            }
            next() { this.idx = (this.idx + 1) % 3; this.update(); }
            prev() { this.idx = (this.idx - 1 + 3) % 3; this.update(); }
            update() {
                const prev = (this.idx - 1 + 3) % 3;
                const next = (this.idx + 1) % 3;
                this.els.forEach(el => el.className = 'tpl-item tpl-hidden');
                this.els[this.idx].className = 'tpl-item tpl-center';
                this.els[prev].className = 'tpl-item tpl-left';
                this.els[next].className = 'tpl-item tpl-right';
            }
        }

        class RenderSystem {
            constructor() {
                this.inkCanvas = document.getElementById('ink-canvas');
                this.ctx = this.inkCanvas.getContext('2d');
                this.pCanvas = document.getElementById('particle-canvas');
                this.pCtx = this.pCanvas.getContext('2d');
                this.paper = document.getElementById('paper-layer');
                this.tplLayer = document.getElementById('template-layer');
                this.statusEl = document.getElementById('status');
                this.vanishBox = document.getElementById('vanish-bar-box');
                this.vanishFill = document.getElementById('vanish-fill');
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // å¢¨è¿¹è®¾ç½®
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#d93a3a';
                this.ctx.shadowBlur = 2;
                this.ctx.shadowColor = '#800';
                this.ctx.lineWidth = 7;

                this.particles = [];
                this.isBurning = false;
                this.burnStartTime = 0;
                this.BURN_DURATION = 2800; // ç‡ƒçƒ§æŒç»­æ—¶é—´
                
                this.burnLayers = [this.paper, this.inkCanvas, this.tplLayer];
                this.loop();
            }

            resize() {
                const r = this.paper.getBoundingClientRect();
                this.inkCanvas.width = r.width; this.inkCanvas.height = r.height;
                // ç²’å­ç”»å¸ƒæ›´å¤§ï¼Œä»¥å®¹çº³é£˜å‡ºçš„ç«ç„°
                this.pCanvas.width = r.width * 1.4; this.pCanvas.height = r.height * 1.4;
                
                // é‡ç½®ä¸Šä¸‹æ–‡
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#d93a3a';
                this.ctx.lineWidth = 7;
                this.ctx.shadowBlur = 2;
                this.ctx.shadowColor = '#800';
            }

            drawSegment(p1, p2) {
                if (!p1 || !p2) return;
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.quadraticCurveTo((p1.x + p2.x)/2, (p1.y + p2.y)/2, p2.x, p2.y);
                this.ctx.stroke();
            }

            setChargingState(active) {
                if (active) this.paper.classList.add('charging-anim');
                else this.paper.classList.remove('charging-anim');
            }

            triggerBurn() {
                this.setChargingState(false);
                this.isBurning = true;
                this.burnStartTime = Date.now();
            }

            resetBurn() {
                this.isBurning = false;
                this.burnLayers.forEach(el => {
                    el.style.webkitMaskImage = '';
                    el.style.maskImage = '';
                    el.style.opacity = 1;
                });
                this.ctx.clearRect(0, 0, this.inkCanvas.width, this.inkCanvas.height);
                this.particles = []; // æ¸…ç©ºç²’å­
            }

            updateVanishBar(pct) {
                if(pct > 0) {
                    this.vanishBox.style.opacity = 1;
                    this.vanishFill.style.width = `${pct * 100}%`;
                } else {
                    this.vanishBox.style.opacity = 0;
                    this.vanishFill.style.width = '0%';
                }
            }
            
            setStatus(text, color='#fff') { 
                this.statusEl.innerText = text; 
                this.statusEl.style.color = color;
                if(color !== '#fff') this.statusEl.style.textShadow = `0 0 20px ${color}`;
                else this.statusEl.style.textShadow = '0 0 10px #000';
            }
            
            // --- æ ¸å¿ƒï¼šçœŸç«ç²’å­ç”Ÿæˆ ---
            spawnFireParticles(yPos, width) {
                const count = 12; // æ¯å¸§ç”Ÿæˆçš„ç²’å­æ•°
                // åæ ‡è½¬æ¢ï¼šä» GameArea åæ ‡è½¬åˆ° ParticleCanvas åæ ‡
                // ParticleCanvas åç§»äº† -20%, å®½é«˜ 140%
                // offsetX = pCanvas.width * (20/140)
                const offsetX = this.pCanvas.width * (0.2 / 1.4);
                const offsetY = this.pCanvas.height * (0.2 / 1.4);
                
                // GameArea é«˜åº¦å¯¹åº”æ¯”ä¾‹
                const scaleY = (this.pCanvas.height / 1.4) / 580; 
                const spawnY = offsetY + yPos * scaleY;
                
                const gameW = this.inkCanvas.width;
                const scaleX = (this.pCanvas.width / 1.4) / gameW;

                for(let i=0; i<count; i++) {
                    const r = Math.random();
                    // ç²’å­ç±»å‹åˆ†å¸ƒï¼š
                    // 0.0 - 0.4: ä¸»ç«ç„° (å¤§ï¼Œæ©™çº¢)
                    // 0.4 - 0.6: æ ¸å¿ƒç«ç„° (äº®é»„ç™½)
                    // 0.6 - 0.9: çƒŸé›¾/çƒ­æµª
                    // 0.9 - 1.0: ç«æ˜Ÿ (æå¿«ï¼Œäº®)

                    let p = {
                        x: offsetX + (Math.random() * gameW) * scaleX,
                        y: spawnY + (Math.random() * 20 - 10), 
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: 0,
                        life: 1.0,
                        maxLife: 1.0,
                        size: 0,
                        type: 'fire'
                    };

                    if (r < 0.5) { // ä¸»ç«ç„°
                        p.type = 'flame';
                        p.vy = -Math.random() * 3 - 2;
                        p.size = Math.random() * 25 + 15;
                        p.life = Math.random() * 0.5 + 0.3;
                        p.color = `255, ${Math.floor(Math.random()*100)}, 0`; // æ©™çº¢
                    } else if (r < 0.7) { // æ ¸å¿ƒäº®ç«
                        p.type = 'core';
                        p.vy = -Math.random() * 4 - 3;
                        p.size = Math.random() * 20 + 10;
                        p.life = Math.random() * 0.4 + 0.2;
                        p.color = `255, ${200 + Math.floor(Math.random()*55)}, 150`; // ç™½é»„
                    } else if (r < 0.9) { // çƒŸ
                        p.type = 'smoke';
                        p.vx = (Math.random() - 0.5) * 3;
                        p.vy = -Math.random() * 2 - 1;
                        p.size = Math.random() * 30 + 10;
                        p.life = Math.random() * 0.8 + 0.4;
                        p.color = '50, 50, 50'; // é»‘ç°
                    } else { // ç«æ˜Ÿ
                        p.type = 'spark';
                        p.vx = (Math.random() - 0.5) * 6;
                        p.vy = -Math.random() * 6 - 4;
                        p.size = Math.random() * 3 + 1;
                        p.life = Math.random() * 0.6 + 0.3;
                        p.color = '255, 255, 200';
                    }
                    this.particles.push(p);
                }
            }

            loop() {
                // 1. æ¸…ç©ºç”»å¸ƒ
                this.pCtx.clearRect(0, 0, this.pCanvas.width, this.pCanvas.height);

                if (this.isBurning) {
                    const elapsed = Date.now() - this.burnStartTime;
                    const progress = Math.min(1, elapsed / this.BURN_DURATION);
                    
                    // è®¡ç®—ç‡ƒçƒ§çº¿çš„ä½ç½® (ä»ä¸‹ 100% å¾€ä¸Š 0%)
                    // Mask logic: transparent at top, black at bottom. 
                    // Gradient stop moves from 100% (all black) to 0% (all transparent)
                    
                    const burnYPct = 100 - (progress * 100); 
                    
                    // åº”ç”¨ Mask
                    const maskCSS = `linear-gradient(to bottom, black ${burnYPct}%, transparent ${burnYPct}%)`;
                    this.burnLayers.forEach(el => {
                        el.style.webkitMaskImage = maskCSS;
                        el.style.maskImage = maskCSS;
                    });
                    // 2. ç”Ÿæˆç«ç„°ç²’å­
                    if (progress < 1.0) {
                        const gameH = 580;
                        const lineY = gameH * (burnYPct / 100);
                        this.spawnFireParticles(lineY, gameH);
                    } else {
                        // ç‡ƒçƒ§ç»“æŸï¼Œç­‰å¾…ç²’å­æ¶ˆå¤±
                        if (this.particles.length === 0) {
                            // å½»åº•ç»“æŸ
                        }
                    }
                }

                // 3. æ¸²æŸ“ç²’å­ (çœŸç«æ ¸å¿ƒæ¸²æŸ“é€»è¾‘)
                // å…³é”®ï¼šä½¿ç”¨ 'lighter' (Additive Blending) å®ç°å‘å…‰å åŠ 
                this.pCtx.globalCompositeOperation = 'lighter';

                for (let i = 0; i < this.particles.length; i++) {
                    let p = this.particles[i];
                    
                    // ç‰©ç†æ›´æ–°
                    p.x += p.vx + Math.sin(Date.now() * 0.01 + p.y * 0.02) * 0.5; // æ¹æµæ‰°åŠ¨
                    p.y += p.vy;
                    p.life -= 0.02;
                    p.size *= 0.95; // é€æ¸å˜å°

                    if (p.life <= 0 || p.size < 0.5) {
                        this.particles.splice(i, 1);
                        i--;
                        continue;
                    }

                    // æ¸²æŸ“é€»è¾‘
                    if (p.type === 'spark') {
                        // ç«æ˜Ÿï¼šç”»å®å¿ƒäº®åœ†ï¼Œå¸¦æ‹–å°¾æ„Ÿ
                        this.pCtx.fillStyle = `rgba(${p.color}, ${p.life})`;
                        this.pCtx.beginPath();
                        this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                        this.pCtx.fill();
                    } else if (p.type === 'smoke') {
                        // çƒŸé›¾ä¸éœ€è¦é«˜äº®å åŠ ï¼Œæ”¾åˆ°åé¢ç”»ï¼Œæˆ–è€…è¿™é‡Œå•ç‹¬å¤„ç†
                        // ä¸ºäº†ç®€å•ï¼Œè¿™é‡ŒçƒŸä¹Ÿå¸¦ä¸€ç‚¹å…‰ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥åˆ‡æ¢ globalCompositeOperation
                        // ä½†é¢‘ç¹åˆ‡æ¢å½±å“æ€§èƒ½ã€‚è¿™é‡Œè®©çƒŸé›¾ä¹Ÿä½œä¸ºä¸€ç§æš—çº¢çƒ­æ°”å¤„ç†
                        let alpha = p.life * 0.4;
                        this.createGradient(p, alpha);
                    } else {
                        // ç«ç„°å’Œæ ¸å¿ƒï¼šä½¿ç”¨å¾„å‘æ¸å˜
                        let alpha = p.life;
                        if (p.type === 'core') alpha = p.life * 0.8;
                        this.createGradient(p, alpha);
                    }
                }
                
                // æ¢å¤é»˜è®¤æ··åˆæ¨¡å¼
                this.pCtx.globalCompositeOperation = 'source-over';
                
                requestAnimationFrame(() => this.loop());
            }

            createGradient(p, alpha) {
                // åˆ›å»ºå¾„å‘æ¸å˜ï¼šä¸­å¿ƒäº® -> è¾¹ç¼˜é€æ˜
                // è¿™æ¨¡æ‹Ÿäº†ç«çƒçš„å½¢æ€
                try {
                    let grad = this.pCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    grad.addColorStop(0, `rgba(${p.color}, ${alpha})`);
                    grad.addColorStop(0.4, `rgba(${p.color}, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(${p.color}, 0)`);
                    
                    this.pCtx.fillStyle = grad;
                    this.pCtx.beginPath();
                    this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.pCtx.fill();
                } catch(e) {}
            }
        }
       
        class GestureBrain {
            constructor(renderer, tplSystem) {
                this.r = renderer;
                this.tpl = tplSystem;
                this.state = 'IDLE'; 
                this.drawStartTime = 0;
                this.lastPos = null;
                
                this.vanishStartTime = 0;
                this.VANISH_TRIGGER_TIME = decreeTime * 1000; 

                this.palmHistory = [];
                this.swipeCooldown = false;
            }

            dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

            isSwordFinger(lm) {
                const wrist = lm[0];
                const ext = (t, p) => this.dist(t, wrist) > this.dist(p, wrist) * 1.1;
                const fold = (t, p) => this.dist(t, wrist) < this.dist(p, wrist) * 1.2;
                return ext(lm[8], lm[6]) && ext(lm[12], lm[10]) && fold(lm[16], lm[14]) && fold(lm[20], lm[18]);
            }

            detectSwipe(lm) {
                if (this.swipeCooldown) return;
                const palmX = lm[9].x;
                const now = Date.now();
                this.palmHistory.push({ x: palmX, time: now });
                this.palmHistory = this.palmHistory.filter(h => now - h.time < 300);
                if (this.palmHistory.length < 5) return;
                const dx = this.palmHistory[this.palmHistory.length-1].x - this.palmHistory[0].x;
                if (Math.abs(dx) > 0.2) {
                    if (dx > 0) { this.tpl.prev(); this.r.setStatus("<< ä¸Šä¸€ä¸ª"); }
                    else { this.tpl.next(); this.r.setStatus("ä¸‹ä¸€ä¸ª >>"); }
                    this.swipeCooldown = true; this.palmHistory = [];
                    setTimeout(() => this.swipeCooldown = false, 500);
                }
            }

            processHand(lm) {
                if (this.state === 'WAITING_FOR_VANISH') {
                    this.vanishStartTime = 0;
                    this.r.updateVanishBar(0);
                    this.r.setChargingState(false);
                    this.state = 'DRAWING'; 
                    this.r.setStatus("æ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œç»§ç»­ç»˜åˆ¶...", "#f0c239");
                    this.lastPos = null;
                }
                
                if(this.state === 'COOLDOWN') return;

                const isSword = this.isSwordFinger(lm);
                const tip = lm[8];
                const cX = (1 - tip.x) * this.r.inkCanvas.width;
                const cY = tip.y * this.r.inkCanvas.height;

                if (isSword) {
                    this.palmHistory = [];
                    if (this.state === 'IDLE') {
                        this.state = 'DRAWING';
                        this.drawStartTime = Date.now();
                        this.lastPos = {x: cX, y: cY};
                        this.r.setStatus("ç”»ç¬¦ä¸­...", "#f0c239");
                    } else if (this.state === 'DRAWING') {
                        if (this.lastPos) {
                            this.r.drawSegment(this.lastPos, {x: cX, y: cY});
                        }
                        this.lastPos = {x: cX, y: cY};
                    }
                } else {
                    if (this.state === 'IDLE') this.detectSwipe(lm);
                    else if (this.state === 'DRAWING') {
                        this.lastPos = null; 
                    }
                }
            }

            checkVanishing() {
                if (this.state !== 'DRAWING' && this.state !== 'WAITING_FOR_VANISH') return;

                const now = Date.now();

                if (this.state === 'DRAWING') {
                    this.state = 'WAITING_FOR_VANISH';
                    this.vanishStartTime = now;
                    this.r.setChargingState(true);
                }

                const elapsed = now - this.vanishStartTime;
                const progress = Math.min(1, elapsed / this.VANISH_TRIGGER_TIME);
                
                this.r.updateVanishBar(progress);
                const sec = (decreeTime - elapsed/1000).toFixed(1);
                this.r.setStatus(`æ••ç¬¦è“„åŠ›ä¸­... ${sec}s`, `rgba(255, ${100 + progress*155}, ${100}, 1)`);

                if (elapsed >= this.VANISH_TRIGGER_TIME) {
                    this.triggerFinish();
                }
            }

            triggerFinish() {
                this.state = 'COOLDOWN';
                this.r.updateVanishBar(0);
                this.r.setChargingState(false);
                this.r.setStatus("æ€¥æ€¥å¦‚å¾‹ä»¤ï¼æ••ï¼", "#ff0000");
                this.r.triggerBurn(); 
                
                setTimeout(() => {
                    this.r.resetBurn();
                    this.state = 'IDLE';
                    this.lastPos = null;
                    this.r.setStatus("å‡†å¤‡å°±ç»ª");
                }, 3500); 
            }
        }

        const tpl = new TemplateSystem();
        const render = new RenderSystem();
        const brain = new GestureBrain(render, tpl);
        
        const videoEl = document.getElementById('cam-video');
        const overlayCanvas = document.getElementById('cam-overlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        const camBox = document.getElementById('cam-box');

        let isSkeleton = false;
        document.getElementById('btn-toggle').onclick = function() {
            isSkeleton = !isSkeleton;
            camBox.style.borderColor = isSkeleton ? '#c92a2a' : '#444';
            videoEl.style.opacity = isSkeleton ? 0 : 0.8;
            this.innerText = isSkeleton ? "åˆ‡æ¢: éª¨éª¼æ¨¡å¼" : "åˆ‡æ¢: å®æ™¯æ¨¡å¼";
        };

        function resizeOverlay() { overlayCanvas.width = camBox.offsetWidth; overlayCanvas.height = camBox.offsetHeight; }
        window.addEventListener('resize', resizeOverlay);
        resizeOverlay();

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });

        hands.onResults(results => {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(overlayCtx, lm, HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.4)', lineWidth: 1});
                drawLandmarks(overlayCtx, lm, {color: '#fff', radius: 1});
                
                brain.processHand(lm);
            } else {
                brain.checkVanishing();
            }
        });

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ navigator.mediaDevices æ›¿ä»£ Camera ç±» ---

        async function startCamera() {
            try {
                // è·å–æ‘„åƒå¤´æµ
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user' // ä¼˜å…ˆä½¿ç”¨å‰ç½®æ‘„åƒå¤´
                    },
                    audio: false
                });

                videoEl.srcObject = stream;
                
                // ç­‰å¾…è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆåæ’­æ”¾
                videoEl.onloadedmetadata = () => {
                    videoEl.play();
                    // å¼€å§‹å°†è§†é¢‘å¸§é€å…¥ hands å¤„ç†çš„å¾ªç¯
                    requestAnimationFrame(sendVideoFrame);
                    render.setStatus("ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸å‡ºå‰‘æŒ‡");
                };

            } catch (err) {
                console.error("Camera access error:", err);
                render.setStatus("ç»åœ°å¤©é€š â€” æ— æ³•è®¿é—®æ‘„åƒå¤´", "red");
            }
        }

        async function sendVideoFrame() {
            if (!videoEl.paused && !videoEl.ended) {
                // å°†è§†é¢‘å…ƒç´ å‘é€ç»™ MediaPipe
                await hands.send({image: videoEl});
            }
            requestAnimationFrame(sendVideoFrame);
        }

        // å¯åŠ¨
        startCamera();

    </script>
</body>
</html>
