<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰‘æŒ‡ç”»ç¬¦</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root { --paper-w: 330px; --paper-h: 580px; }
        
        body { 
            margin: 0; 
            background: #050505;
            height: 100vh; 
            overflow: hidden; 
            font-family: "KaiTi", serif; 
            position: relative; 
        }

        #game-area { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: var(--paper-w); 
            height: var(--paper-h); 
            perspective: 1000px; 
            transform: translate(-50%, -50%); 
            z-index: 5;
        }

        /* 1. ç¬¦çº¸å±‚ */
        #paper-layer {
            position: absolute; inset: 0; z-index: 1;
            background: #f0c239;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.2'/%3E%3C/svg%3E");
            border: 2px solid #d4a017;
        }

        /* 2. æ¨¡æ¿å±‚ */
        #template-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
            display: flex; justify-content: center; align-items: center;
        }
        .tpl-item { position: absolute; width: 80%; height: 80%; transition: all 0.4s ease; opacity: 0; }
        .tpl-item svg { width: 100%; height: 100%; fill: none; stroke: rgba(255, 255, 255, 0.25); stroke-width: 8; stroke-linecap: round; stroke-linejoin: round; }
        .tpl-center { transform: translateX(0) scale(1); opacity: 1; z-index: 10; }
        .tpl-left   { transform: translateX(-120%) scale(0.8); opacity: 0.3; }
        .tpl-right  { transform: translateX(120%) scale(0.8); opacity: 0.3; }
        .tpl-hidden { transform: scale(0.5); opacity: 0; }

        /* 3. ç¬”è¿¹ä¸ç²’å­ */
        canvas { position: absolute; inset: 0; pointer-events: none; }
        #ink-canvas { z-index: 3; }
        #particle-canvas { z-index: 4; width: 140%; height: 140%; left: -20%; top: -20%; }

        /* åŠ¨ç”»ç‰¹æ•ˆ */
        .charging-anim {
            animation: shake 0.1s infinite;
            box-shadow: 0 0 40px #ff4400 !important;
            border-color: #ff2200 !important;
        }

        @keyframes shake {
            0% { transform: rotate(0deg) translate(0,0); }
            25% { transform: rotate(0.5deg) translate(1px, 1px); }
            50% { transform: rotate(0deg) translate(0,0); }
            75% { transform: rotate(-0.5deg) translate(-1px, -1px); }
            100% { transform: rotate(0deg) translate(0,0); }
        }

        /* UI */
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
        
        #cam-box { 
            position: absolute; bottom: 60px; left: 20px; 
            width: 240px; height: auto; 
            background: #000; border: 2px solid #444; 
            border-radius: 8px; overflow: hidden; 
            transition: border-color 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        #cam-video { width: 100%; height: auto; display: block; transform: scaleX(-1); opacity: 0.8; }
        #cam-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #status { position: absolute; top: 30px; width: 100%; text-align: center; color: #fff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #ff0000; transition: color 0.3s; }
        #guide-hint { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; }
        
        #vanish-bar-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 220px; height: 10px; background: rgba(0,0,0,0.6); border-radius: 10px;
            opacity: 0; transition: opacity 0.3s;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 15px #ff4400;
        }
        #vanish-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff0000, #ffaa00, #ffffaa); border-radius: 10px; transition: width 0.05s linear; }

        #btn-toggle { position: absolute; bottom: 20px; left: 20px; width: 240px;pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #ccc; padding: 5px 10px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="game-area">
        <div id="paper-layer"></div>
        <div id="template-layer">
            <div class="tpl-item" id="tpl-0"></div>
            <div class="tpl-item" id="tpl-1"></div>
            <div class="tpl-item" id="tpl-2"></div>
        </div>
        <canvas id="ink-canvas"></canvas>
        <canvas id="particle-canvas"></canvas>
        <div id="vanish-bar-box"><div id="vanish-fill"></div></div>
    </div>

    <div id="ui-layer">
        <button id="btn-toggle">åˆ‡æ¢: å®æ™¯æ¨¡å¼</button>
        <div id="status">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
        <div id="guide-hint">ğŸ–ï¸ å·¦å³æŒ¥æ‰‹åˆ‡æ¢æ¨¡æ¿<br>âœŒï¸ å‰‘æŒ‡å…¥æ‘„åƒå¤´å†…å¼€å§‹ç”»ç¬¦<br>
            ç”»å®Œåå°†æ‰‹å¿«é€Ÿç§»å‘æ‘„åƒå¤´
        </div>
        <div id="cam-box">
            <video id="cam-video" playsinline></video>
            <canvas id="cam-overlay"></canvas>
        </div>
    </div>

    <script>
        var decreeTime = 0.8 

        const TEMPLATES = [
            `<path d="M50,20 L250,20 M150,20 L150,100 M80,120 L220,120 M150,120 L150,200 M100,220 Q150,300 200,220 M150,250 L150,500 M120,400 L180,420 M180,400 L120,420" />`,
            `<path d="M150,30 L150,550 M100,50 L200,50 M100,500 L200,500 M80,150 L220,150 M100,150 Q50,300 100,450 M200,150 Q250,300 200,450 M130,250 L170,250 L170,350 L130,350 Z" />`,
            `<path d="M150,20 L150,560 M120,50 L180,60 M120,100 L180,110 M120,150 L180,160 M100,200 L200,200 M150,200 Q250,300 150,400 Q50,300 150,200 M150,400 L120,550 M150,400 L180,550" />`
        ];

        class TemplateSystem {
            constructor() {
                this.idx = 0;
                this.els = [document.getElementById('tpl-0'), document.getElementById('tpl-1'), document.getElementById('tpl-2')];
                this.els.forEach((el, i) => el.innerHTML = `<svg viewBox="0 0 300 600">${TEMPLATES[i]}</svg>`);
                this.update();
            }
            next() { this.idx = (this.idx + 1) % 3; this.update(); }
            prev() { this.idx = (this.idx - 1 + 3) % 3; this.update(); }
            update() {
                const prev = (this.idx - 1 + 3) % 3;
                const next = (this.idx + 1) % 3;
                this.els.forEach(el => el.className = 'tpl-item tpl-hidden');
                this.els[this.idx].className = 'tpl-item tpl-center';
                this.els[prev].className = 'tpl-item tpl-left';
                this.els[next].className = 'tpl-item tpl-right';
            }
        }

        class RenderSystem {
            constructor() {
                this.inkCanvas = document.getElementById('ink-canvas');
                this.ctx = this.inkCanvas.getContext('2d');
                this.pCanvas = document.getElementById('particle-canvas');
                this.pCtx = this.pCanvas.getContext('2d');
                this.paper = document.getElementById('paper-layer');
                this.tplLayer = document.getElementById('template-layer');
                this.statusEl = document.getElementById('status');
                this.vanishBox = document.getElementById('vanish-bar-box');
                this.vanishFill = document.getElementById('vanish-fill');
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#d93a3a';
                this.ctx.shadowBlur = 2;
                this.ctx.shadowColor = '#800';
                this.ctx.lineWidth = 7;

                this.particles = [];
                this.isBurning = false;
                this.burnStartTime = 0;
                this.BURN_DURATION = 2800; 
                
                this.burnLayers = [this.paper, this.inkCanvas, this.tplLayer];
                this.loop();
            }

            resize() {
                const r = this.paper.getBoundingClientRect();
                this.inkCanvas.width = r.width; this.inkCanvas.height = r.height;
                this.pCanvas.width = r.width * 1.4; this.pCanvas.height = r.height * 1.4;
                
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#d93a3a';
                this.ctx.lineWidth = 7;
                this.ctx.shadowBlur = 2;
                this.ctx.shadowColor = '#800';
            }

            drawSegment(p1, p2) {
                if (!p1 || !p2) return;
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.quadraticCurveTo((p1.x + p2.x)/2, (p1.y + p2.y)/2, p2.x, p2.y);
                this.ctx.stroke();
            }

            setChargingState(active) {
                if (active) this.paper.classList.add('charging-anim');
                else this.paper.classList.remove('charging-anim');
            }

            triggerBurn() {
                this.setChargingState(false);
                this.isBurning = true;
                this.burnStartTime = Date.now();
            }

            resetBurn() {
                this.isBurning = false;
                this.burnLayers.forEach(el => {
                    el.style.webkitMaskImage = '';
                    el.style.maskImage = '';
                    el.style.opacity = 1;
                });
                this.ctx.clearRect(0, 0, this.inkCanvas.width, this.inkCanvas.height);
                this.particles = [];
            }

            updateVanishBar(pct) {
                if(pct > 0) {
                    this.vanishBox.style.opacity = 1;
                    this.vanishFill.style.width = `${pct * 100}%`;
                } else {
                    this.vanishBox.style.opacity = 0;
                    this.vanishFill.style.width = '0%';
                }
            }
            
            setStatus(text, color='#fff') { 
                this.statusEl.innerText = text; 
                this.statusEl.style.color = color;
                if(color !== '#fff') this.statusEl.style.textShadow = `0 0 20px ${color}`;
                else this.statusEl.style.textShadow = '0 0 10px #000';
            }
            
            spawnFireParticles(yPos, width) {
                const count = 12; 
                const offsetX = this.pCanvas.width * (0.2 / 1.4);
                const offsetY = this.pCanvas.height * (0.2 / 1.4);
                
                const scaleY = (this.pCanvas.height / 1.4) / 580; 
                const spawnY = offsetY + yPos * scaleY;
                
                const gameW = this.inkCanvas.width;
                const scaleX = (this.pCanvas.width / 1.4) / gameW;

                for(let i=0; i<count; i++) {
                    const r = Math.random();
                    let p = {
                        x: offsetX + (Math.random() * gameW) * scaleX,
                        y: spawnY + (Math.random() * 20 - 10), 
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: 0,
                        life: 1.0,
                        maxLife: 1.0,
                        size: 0,
                        type: 'fire'
                    };

                    if (r < 0.5) { // ä¸»ç«ç„°
                        p.type = 'flame';
                        p.vy = -Math.random() * 3 - 2;
                        p.size = Math.random() * 25 + 15;
                        p.life = Math.random() * 0.5 + 0.3;
                        p.color = `255, ${Math.floor(Math.random()*100)}, 0`;
                    } else if (r < 0.7) { // æ ¸å¿ƒ
                        p.type = 'core';
                        p.vy = -Math.random() * 4 - 3;
                        p.size = Math.random() * 20 + 10;
                        p.life = Math.random() * 0.4 + 0.2;
                        p.color = `255, ${200 + Math.floor(Math.random()*55)}, 150`;
                    } else if (r < 0.9) { // çƒŸ/çƒ­æµª
                        p.type = 'smoke';
                        p.vx = (Math.random() - 0.5) * 3;
                        p.vy = -Math.random() * 2 - 1;
                        p.size = Math.random() * 30 + 10;
                        p.life = Math.random() * 0.8 + 0.4;
                        p.color = '50, 50, 50';
                    } else { // ç«æ˜Ÿ
                        p.type = 'spark';
                        p.vx = (Math.random() - 0.5) * 6;
                        p.vy = -Math.random() * 6 - 4;
                        p.size = Math.random() * 3 + 1;
                        p.life = Math.random() * 0.6 + 0.3;
                        p.color = '255, 255, 200';
                    }
                    this.particles.push(p);
                }
            }

            loop() {
                this.pCtx.clearRect(0, 0, this.pCanvas.width, this.pCanvas.height);

                if (this.isBurning) {
                    const elapsed = Date.now() - this.burnStartTime;
                    const progress = Math.min(1, elapsed / this.BURN_DURATION);
                    
                    // 100 -> 0 (ä»ä¸‹å¾€ä¸Šå‡å°‘å¯è§åŒºåŸŸ)
                    const burnYPct = 100 - (progress * 100); 
                    
                    // --- ä¿®æ­£é‡ç‚¹ï¼šä½¿ç”¨ 'to bottom' æ¸å˜ ---
                    // to bottom: é¢œè‰²ä»ä¸Šå¾€ä¸‹ç»˜åˆ¶ã€‚
                    // black 0% -> burnYPct% : ä¸ŠåŠéƒ¨åˆ†é»‘è‰²ï¼ˆå¯è§ï¼‰
                    // transparent burnYPct% -> ... : ä¸‹åŠéƒ¨åˆ†é€æ˜ï¼ˆæ¶ˆå¤±ï¼‰
                    const maskCSS = `linear-gradient(to bottom, black ${burnYPct}%, transparent ${burnYPct}%)`;
                    
                    this.burnLayers.forEach(el => {
                        el.style.webkitMaskImage = maskCSS;
                        el.style.maskImage = maskCSS;
                    });

                    if (progress < 1.0) {
                        const gameH = 580;
                        // è®¡ç®—ç‡ƒçƒ§çº¿çš„ Y åæ ‡ï¼ˆåƒç´ ï¼‰
                        // burnYPct = 100% -> Y = Bottom (580)
                        // burnYPct = 0%   -> Y = Top (0)
                        const lineY = gameH * (burnYPct / 100);
                        this.spawnFireParticles(lineY, gameH);
                    } else {
                        if (this.particles.length === 0) {}
                    }
                }

                this.pCtx.globalCompositeOperation = 'lighter';

                for (let i = 0; i < this.particles.length; i++) {
                    let p = this.particles[i];
                    
                    p.x += p.vx + Math.sin(Date.now() * 0.01 + p.y * 0.02) * 0.5;
                    p.y += p.vy;
                    p.life -= 0.02;
                    p.size *= 0.95;

                    if (p.life <= 0 || p.size < 0.5) {
                        this.particles.splice(i, 1);
                        i--;
                        continue;
                    }

                    if (p.type === 'spark') {
                        this.pCtx.fillStyle = `rgba(${p.color}, ${p.life})`;
                        this.pCtx.beginPath();
                        this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                        this.pCtx.fill();
                    } else if (p.type === 'smoke') {
                        let alpha = p.life * 0.4;
                        this.createGradient(p, alpha);
                    } else {
                        let alpha = p.life;
                        if (p.type === 'core') alpha = p.life * 0.8;
                        this.createGradient(p, alpha);
                    }
                }
                
                this.pCtx.globalCompositeOperation = 'source-over';
                requestAnimationFrame(() => this.loop());
            }

            createGradient(p, alpha) {
                try {
                    let grad = this.pCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    grad.addColorStop(0, `rgba(${p.color}, ${alpha})`);
                    grad.addColorStop(0.4, `rgba(${p.color}, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(${p.color}, 0)`);
                    
                    this.pCtx.fillStyle = grad;
                    this.pCtx.beginPath();
                    this.pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.pCtx.fill();
                } catch(e) {}
            }
        }
        
        class GestureBrain {
            constructor(renderer, tplSystem) {
                this.r = renderer;
                this.tpl = tplSystem;
                this.state = 'IDLE'; 
                this.lastPos = null;
                this.vanishStartTime = 0;
                this.VANISH_TRIGGER_TIME = decreeTime * 1000; 
                this.palmHistory = [];
                this.swipeCooldown = false;
            }

            dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

            isSwordFinger(lm) {
                const wrist = lm[0];
                const ext = (t, p) => this.dist(t, wrist) > this.dist(p, wrist) * 1.1;
                const fold = (t, p) => this.dist(t, wrist) < this.dist(p, wrist) * 1.2;
                return ext(lm[8], lm[6]) && ext(lm[12], lm[10]) && fold(lm[16], lm[14]) && fold(lm[20], lm[18]);
            }

            detectSwipe(lm) {
                if (this.swipeCooldown) return;
                const palmX = lm[9].x;
                const now = Date.now();
                this.palmHistory.push({ x: palmX, time: now });
                this.palmHistory = this.palmHistory.filter(h => now - h.time < 300);
                if (this.palmHistory.length < 5) return;
                const dx = this.palmHistory[this.palmHistory.length-1].x - this.palmHistory[0].x;
                if (Math.abs(dx) > 0.15) { 
                    if (dx > 0) { this.tpl.prev(); this.r.setStatus("<< ä¸Šä¸€ä¸ª"); }
                    else { this.tpl.next(); this.r.setStatus("ä¸‹ä¸€ä¸ª >>"); }
                    this.swipeCooldown = true; this.palmHistory = [];
                    setTimeout(() => this.swipeCooldown = false, 500);
                }
            }

            processHand(lm) {
                if (this.state === 'WAITING_FOR_VANISH') {
                    this.vanishStartTime = 0;
                    this.r.updateVanishBar(0);
                    this.r.setChargingState(false);
                    this.state = 'DRAWING'; 
                    this.r.setStatus("æ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œç»§ç»­ç»˜åˆ¶...", "#f0c239");
                    this.lastPos = null;
                }
                
                if(this.state === 'COOLDOWN') return;

                const isSword = this.isSwordFinger(lm);
                const tip = lm[8];
                const cX = (1 - tip.x) * this.r.inkCanvas.width;
                const cY = tip.y * this.r.inkCanvas.height;

                if (isSword) {
                    this.palmHistory = [];
                    if (this.state === 'IDLE') {
                        this.state = 'DRAWING';
                        this.lastPos = {x: cX, y: cY};
                        this.r.setStatus("ç”»ç¬¦ä¸­...", "#f0c239");
                    } else if (this.state === 'DRAWING') {
                        if (this.lastPos) {
                            const smoothX = this.lastPos.x * 0.3 + cX * 0.7;
                            const smoothY = this.lastPos.y * 0.3 + cY * 0.7;
                            this.r.drawSegment(this.lastPos, {x: smoothX, y: smoothY});
                            this.lastPos = {x: smoothX, y: smoothY};
                        } else {
                             this.lastPos = {x: cX, y: cY};
                        }
                    }
                } else {
                    if (this.state === 'IDLE') this.detectSwipe(lm);
                    else if (this.state === 'DRAWING') {
                        this.lastPos = null; 
                    }
                }
            }

            checkVanishing() {
                if (this.state !== 'DRAWING' && this.state !== 'WAITING_FOR_VANISH') return;

                const now = Date.now();
                if (this.state === 'DRAWING') {
                    this.state = 'WAITING_FOR_VANISH';
                    this.vanishStartTime = now;
                    this.r.setChargingState(true);
                }

                const elapsed = now - this.vanishStartTime;
                const progress = Math.min(1, elapsed / this.VANISH_TRIGGER_TIME);
                
                this.r.updateVanishBar(progress);
                const sec = (decreeTime - elapsed/1000).toFixed(1);
                
                const r = 255;
                const g = Math.floor(200 * (1 - progress));
                const b = Math.floor(100 * (1 - progress));
                this.r.setStatus(`æ••ç¬¦è“„åŠ›ä¸­... ${sec}s`, `rgb(${r}, ${g}, ${b})`);

                if (elapsed >= this.VANISH_TRIGGER_TIME) {
                    this.triggerFinish();
                }
            }

            triggerFinish() {
                this.state = 'COOLDOWN';
                this.r.updateVanishBar(0);
                this.r.setStatus("æ€¥æ€¥å¦‚å¾‹ä»¤ï¼æ••ï¼", "#ff2200");
                this.r.triggerBurn(); 
                
                setTimeout(() => {
                    this.r.resetBurn();
                    this.state = 'IDLE';
                    this.lastPos = null;
                    this.r.setStatus("å‡†å¤‡å°±ç»ª");
                }, 3500); 
            }
        }

        const tpl = new TemplateSystem();
        const render = new RenderSystem();
        const brain = new GestureBrain(render, tpl);
        
        const videoEl = document.getElementById('cam-video');
        const overlayCanvas = document.getElementById('cam-overlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        const camBox = document.getElementById('cam-box');

        let isSkeleton = false;
        document.getElementById('btn-toggle').onclick = function() {
            isSkeleton = !isSkeleton;
            camBox.style.borderColor = isSkeleton ? '#c92a2a' : '#444';
            videoEl.style.opacity = isSkeleton ? 0 : 0.8;
            this.innerText = isSkeleton ? "åˆ‡æ¢: éª¨éª¼æ¨¡å¼" : "åˆ‡æ¢: å®æ™¯æ¨¡å¼";
        };

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });

        hands.onResults(results => {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(overlayCtx, lm, HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.4)', lineWidth: 2});
                drawLandmarks(overlayCtx, lm, {color: '#fff', radius: 2});
                brain.processHand(lm);
            } else {
                brain.checkVanishing();
            }
        });

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                videoEl.srcObject = stream;
                videoEl.onloadedmetadata = () => {
                    videoEl.play();
                    overlayCanvas.width = videoEl.videoWidth;
                    overlayCanvas.height = videoEl.videoHeight;
                    render.setStatus("ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸å‡ºå‰‘æŒ‡");
                    requestAnimationFrame(sendVideoFrame);
                };
            } catch (err) {
                render.setStatus("ç»åœ°å¤©é€š - æ‘„åƒå¤´è®¿é—®å¤±è´¥", "red");
            }
        }

        async function sendVideoFrame() {
            if (!videoEl.paused && !videoEl.ended) {
                await hands.send({image: videoEl});
            }
            requestAnimationFrame(sendVideoFrame);
        }

        startCamera();
    </script>
</body>
</html>
