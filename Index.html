<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¾¡å‰‘é£è¡Œ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #input-video { position: absolute; top:0; left:0; opacity: 0; pointer-events: none; z-index: -1; }

        /* HUD */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud-panel {
            position: absolute; left: 30px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 15px;
            border-left: 2px solid rgba(0, 255, 170, 0.5); padding-left: 15px;
        }
        .hud-item { color: rgba(255, 255, 255, 0.9); font-size: 14px; text-shadow: 0 0 5px #00ffaa; }
        .hud-value { font-size: 24px; font-weight: bold; color: #00ffaa; font-family: monospace; }
        .hud-label { font-size: 10px; color: #aaa; letter-spacing: 1px; }

        /* é¡¶éƒ¨æ  */
        .top-bar {
            position: absolute; top: 20px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box; pointer-events: auto;
        }
        .status-main { font-size: 22px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #00ffaa; }
        .status-sub { font-size: 14px; color: #00ffaa; margin-top: 5px; }

        .control-btn {
            background: rgba(0, 30, 40, 0.8); border: 1px solid #00ffaa; color: #00ffaa;
            padding: 8px 16px; border-radius: 4px; cursor: pointer; transition: 0.2s;
        }
        .control-btn:hover { background: #00ffaa; color: #000; }

        /* å‡†æ˜Ÿ */
        #crosshair-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100px; height: 100px; display: flex; justify-content: center; align-items: center;
        }
        #crosshair {
            width: 40px; height: 40px; border: 2px dashed rgba(255,255,255,0.6); border-radius: 50%;
            transition: all 0.2s; position: absolute;
        }

        /* è°ƒè¯•çª—å£ */
        #debug-wrapper {
            position: absolute; bottom: 20px; left: 20px; z-index: 20; pointer-events: auto;
        }
        #debug-view {
            width: 280px; height: auto; background: #000; border: 1px solid #333; border-radius: 6px; transform: scaleX(-1); display: block;
        }

        /* å¯åŠ¨é¡µ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto;
        }
        #start-btn {
            padding: 15px 50px; font-size: 22px; border: 2px solid #00ffaa;
            background: transparent; color: #00ffaa; border-radius: 50px;
            cursor: pointer; transition: 0.3s; box-shadow: 0 0 20px rgba(0,255,170,0.2);
        }
        #start-btn:hover { background: #00ffaa; color: #000; box-shadow: 0 0 40px #00ffaa; }
        .key-point { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="start-screen">
        <button id="start-btn" onclick="startApp()">âš¡ å¾¡å‰‘é£è¡Œ</button>
        <div style="margin-top:30px; color:#ccc; font-size:14px; text-align:center; line-height:1.8;">
            <div>âœ‹ <span class="key-point">å•æ‰‹</span>ï¼šä½ç½®/é«˜åº¦è·Ÿéš</div>
            <div>ğŸ‘ <span class="key-point">åŒæ‰‹</span>ï¼šå§¿æ€æ§åˆ¶ (æ¨æ‹‰è½¬å‘/é«˜ä½å‡é™)</div>
            <div style="color:#00ffaa; margin-top:10px;">â˜… å‰‘æŒ‡ï¼ˆé£ŸæŒ‡+ä¸­æŒ‡ï¼‰å¯¹å‡†æ‘„åƒå¤´</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input-video" width="640" height="480" playsinline></video>

    <!-- HUD -->
    <div id="hud-layer">
        <div class="top-bar">
            <div>
                <div class="status-main">å¾¡å‰‘é£è¡Œ</div>
                <div class="status-sub" id="mode-text">ç³»ç»Ÿå¾…æœº</div>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="control-btn" onclick="document.getElementById('file-input').click()">ğŸ“¤ æ¢å‰‘</button>
                <button class="control-btn" onclick="resetSword()">â†º é‡ç½®</button>
            </div>
        </div>

        <div class="hud-panel">
            <div class="hud-item">
                <div class="hud-label">ALT (æµ·æ‹”)</div>
                <div class="hud-value" id="hud-alt">3000</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">V.SPD (å‚ç›´é€Ÿåº¦)</div>
                <div class="hud-value" id="hud-vspeed">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">HDG (èˆªå‘)</div>
                <div class="hud-value" id="hud-yaw">0Â°</div>
            </div>
        </div>

        <div id="crosshair-container">
            <div id="crosshair"></div>
        </div>
    </div>

    <div id="debug-wrapper">
        <canvas id="debug-view"></canvas>
        <button class="control-btn" style="width:100%; margin-top:5px;" onclick="toggleCameraView()">ğŸ‘ï¸ åˆ‡æ¢å®æ™¯/çº¿æ¡†</button>
    </div>

    <input type="file" id="file-input" accept=".glb,.gltf" style="display:none">

    <!-- åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- å¯åŠ¨ ---
        async function startApp() {
            const btn = document.getElementById('start-btn');
            btn.innerText = "æ­£åœ¨åˆå§‹åŒ–...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: {ideal:640}, height: {ideal:480} } });
                stream.getTracks().forEach(t => t.stop());
                document.getElementById('start-screen').style.display = 'none';
                initThree();
                initMediaPipe();
            } catch (e) {
                console.error(e);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥HTTPSæˆ–Localhost");
            }
        }

        // --- å‚æ•° ---
        const CONFIG = {
            flySpeed: 1.5,
            singleSpeed: 0.1,
            turnSpeed: 0.05,
            limitX: 20,
            limitY: 12,
            baseAltitude: 3000
        };

        // --- çŠ¶æ€ ---
        let control = { mode: 'IDLE', active: false, targetX: 0, targetY: 0, yawInput: 0, pitchInput: 0, rollInput: 0 };
        let flight = { x: 0, y: 0, z: 0, yaw: 0, pitch: 0, roll: 0, altitude: CONFIG.baseAltitude };
        let showRealCamera = false;

        // --- Three.js ---
        let scene, camera, renderer, swordGroup, terrainMesh;

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // ä¿®å¤1: é›¾æ•ˆå¤§å¹…å‡å¼±ï¼Œè®©è¿œå¤„å±±è„‰å¯è§
            scene.fog = new THREE.FogExp2(0x0a1525, 0.002); 
            scene.background = new THREE.Color(0x0a1525);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000); // è¿œè§†è·åŠ å¤§
            camera.position.set(0, 6, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x404040, 2));
            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(50, 200, 100);
            sun.castShadow = true;
            scene.add(sun);

            createSevenStarSword();
            createTerrain();
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- é»˜è®¤å‰‘æ¨¡å‹ ---
        function createSevenStarSword() {
            if (swordGroup) scene.remove(swordGroup);
            swordGroup = new THREE.Group();

            const bladeGeo = new THREE.ConeGeometry(0.6, 12, 4); 
            const bladeMat = new THREE.MeshStandardMaterial({ 
                color: 0xe0ffff, metalness: 0.9, roughness: 0.1, 
                emissive: 0x00ffff, emissiveIntensity: 0.4 
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.scale.set(1, 1, 0.15); 
            blade.rotation.x = Math.PI / 2; // æœå‘ -Z
            blade.position.z = -1;
            swordGroup.add(blade);

            const guard = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.2, 0.5), new THREE.MeshStandardMaterial({color:0xffaa00, metalness:1}));
            guard.position.z = 4.5;
            const w1 = guard.clone(); w1.rotation.z = 0.4; w1.scale.set(0.6,1,1); w1.position.set(-1.2,0,4.5);
            const w2 = guard.clone(); w2.rotation.z = -0.4; w2.scale.set(0.6,1,1); w2.position.set(1.2,0,4.5);
            swordGroup.add(guard); swordGroup.add(w1); swordGroup.add(w2);

            const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 3, 8), new THREE.MeshStandardMaterial({color:0x222222}));
            hilt.rotation.x = Math.PI / 2; hilt.position.z = 6;
            swordGroup.add(hilt);

            for(let i=0; i<7; i++){
                const star = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({color:0x00ffaa}));
                star.position.set(0, 0.06, 3.5 - i*0.9);
                swordGroup.add(star);
            }
            scene.add(swordGroup);
        }

        // --- åœ°å½¢ (ä¿®å¤ï¼šæé«˜å¯è§åº¦ä¸èµ·ä¼) ---
        function createTerrain() {
            // åŠ å¤§å°ºå¯¸ 800x800
            const geometry = new THREE.PlaneGeometry(800, 800, 128, 128);
            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, altitude: { value: 1.0 } },
                vertexShader: `
                    uniform float time; uniform float altitude; varying float vH;
                    float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
                    float noise(vec2 x) {
                        vec2 i = floor(x); vec2 f = fract(x);
                        float a = hash(i); float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }
                    void main() {
                        vec3 pos = position;
                        // ä¿®å¤: ä¿æŒä¸€å®šçš„çº¹ç†ç¼©æ”¾ï¼Œé¿å…å¤ªæ¨¡ç³Š
                        float scale = 0.015; 
                        float move = time * 1.5;
                        
                        // ä¿®å¤: å¢åŠ æŒ¯å¹…åˆ° 140ï¼Œè®©å±±æ›´åƒå±±
                        float h = noise(pos.xy * scale + vec2(0, -move)) * 140.0;
                        
                        // å¢åŠ ç»†èŠ‚å±‚
                        h += noise(pos.xy * scale * 4.0 + vec2(0, -move)) * 20.0;

                        pos.z = h; vH = h;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying float vH;
                    void main() {
                        // é¢œè‰²åˆ†å±‚ï¼šæ·±è°· -> å±±è…° -> é›ªé¡¶
                        vec3 col = mix(vec3(0.05, 0.1, 0.15), vec3(0.3, 0.4, 0.5), smoothstep(0.0, 60.0, vH));
                        col = mix(col, vec3(0.9, 0.95, 1.0), smoothstep(100.0, 140.0, vH));
                        
                        // é›¾æ•ˆæ··åˆ
                        float fog = smoothstep(200.0, 700.0, gl_FragCoord.z / gl_FragCoord.w);
                        gl_FragColor = vec4(mix(col, vec3(0.04, 0.08, 0.15), fog), 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.position.y = -80; // åœ°é¢ä½ç½®
            scene.add(terrainMesh);
        }

        // --- MediaPipe ---
        const debugCanvas = document.getElementById('debug-view');
        const ctx = debugCanvas.getContext('2d');
        const modeText = document.getElementById('mode-text');
        const crosshair = document.getElementById('crosshair');

        function toggleCameraView() { showRealCamera = !showRealCamera; }
        function isSwordFinger(h) { return h[8].y < h[5].y; }

        function initMediaPipe() {
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 640, height: 480 });
            cam.start();
        }

        function onResults(results) {
            if (debugCanvas.width !== results.image.width) {
                debugCanvas.width = results.image.width; debugCanvas.height = results.image.height;
            }
            ctx.save();
            if(showRealCamera) ctx.drawImage(results.image, 0, 0);
            else { ctx.fillStyle="#000"; ctx.fillRect(0,0,debugCanvas.width,debugCanvas.height); }

            const lands = results.multiHandLandmarks;

            if (!lands || lands.length === 0) {
                // å…³é”®ä¿®å¤ï¼šå½“æ²¡æœ‰æ‰‹åŠ¿æ—¶ï¼Œä¸æ”¹å˜ flight æ•°æ®ï¼Œä¿æŒæƒ¯æ€§
                // ä»…æ›´æ–° UI çŠ¶æ€
                control.active = false;
                modeText.innerText = "å§¿æ€ä¿æŒä¸­ (æ— ä¿¡å·)";
                modeText.style.color = "#888";
                crosshair.style.borderColor = "rgba(255,255,255,0.3)";
            } 
            else if (lands.length === 1) {
                control.mode = 'SINGLE'; control.active = true;
                const h = lands[0];
                drawConnectors(ctx, h, HAND_CONNECTIONS, {color:'#00aaff', lineWidth:3});
                if(isSwordFinger(h)) {
                    modeText.innerText = "å•æ‰‹è·Ÿéš"; modeText.style.color = "#00aaff";
                    control.targetX = (h[9].x - 0.5) * CONFIG.limitX * 2.0;
                    control.targetY = (0.5 - h[9].y) * CONFIG.limitY * 2.0;
                }
            }
            else if (lands.length === 2) {
                control.mode = 'DUAL'; control.active = true;
                const sorted = lands.map(h=>h).sort((a,b)=>a[9].x - b[9].x);
                drawConnectors(ctx, sorted[0], HAND_CONNECTIONS, {color:'#00ffaa', lineWidth:3});
                drawConnectors(ctx, sorted[1], HAND_CONNECTIONS, {color:'#00ffaa', lineWidth:3});

                if(isSwordFinger(sorted[0]) && isSwordFinger(sorted[1])) {
                    modeText.innerText = "åŒæ‰‹å¾¡å‰‘"; modeText.style.color = "#00ffaa";
                    const h1=sorted[0], h2=sorted[1];
                    
                    // è½¬å‘
                    const zDiff = h2[9].z - h1[9].z;
                    control.yawInput = -zDiff * 4.0;
                    
                    // ç¿»æ»š
                    const yDiff = h2[9].y - h1[9].y;
                    const slope = Math.atan2(yDiff, h2[9].x - h1[9].x);
                    control.rollInput = slope * 1.5;

                    // å‡é™
                    const avgY = (h1[9].y + h2[9].y) / 2;
                    if(avgY < 0.4) control.pitchInput = -(0.4 - avgY) * 5.0; // æŠ¬å¤´
                    else if(avgY > 0.6) control.pitchInput = (avgY - 0.6) * 5.0; // ä½å¤´
                    else control.pitchInput = 0;
                }
            }
            ctx.restore();
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // åªæœ‰å½“æ£€æµ‹åˆ°æ‰‹åŠ¿ä¸”æ¿€æ´»æ—¶ï¼Œæ‰æ›´æ–° flight å§¿æ€
            if (control.active) {
                if (control.mode === 'SINGLE') {
                    // å•æ‰‹é€»è¾‘
                    flight.x += (control.targetX - flight.x) * CONFIG.singleSpeed;
                    flight.y += (control.targetY - flight.y) * CONFIG.singleSpeed;
                    flight.pitch = (flight.y - control.targetY) * 0.05;
                    flight.roll = (flight.x - control.targetX) * 0.05;
                    flight.yaw *= 0.9; 
                    flight.altitude = CONFIG.baseAltitude + flight.y * 100;
                } 
                else if (control.mode === 'DUAL') {
                    // åŒæ‰‹é€»è¾‘
                    flight.yaw -= control.yawInput * CONFIG.turnSpeed;
                    flight.pitch += (control.pitchInput - flight.pitch) * 0.1;
                    flight.roll += (control.rollInput - flight.roll) * 0.1;
                    
                    flight.x = -flight.yaw * 3;
                    flight.y -= flight.pitch * 0.5;
                }
            }
            
            // ä¿®å¤å…³é”®ï¼šæ— è®ºæœ‰æ²¡æœ‰æ‰‹åŠ¿ï¼Œé«˜åº¦éƒ½å¿…é¡»æ ¹æ®å½“å‰çš„ Pitch ç»§ç»­æ›´æ–°
            // å¦‚æœæ‰‹æ¾å¼€äº†ï¼ŒPitch ä¿æŒåœ¨éé›¶å€¼ï¼Œé‚£ä¹ˆé£å‰‘åº”è¯¥ç»§ç»­ä¸Šå‡/ä¸‹é™
            if (control.mode === 'DUAL' || !control.active) {
                flight.altitude -= flight.pitch * 15;
            }

            // é™åˆ¶
            flight.y = Math.max(-10, Math.min(10, flight.y));
            flight.altitude = Math.max(200, flight.altitude);

            // æ›´æ–° HUD
            document.getElementById('hud-alt').innerText = Math.floor(flight.altitude);
            document.getElementById('hud-vspeed').innerText = Math.floor(-flight.pitch * 100);
            let deg = Math.floor((flight.yaw * 180 / Math.PI) % 360);
            if(deg<0) deg+=360;
            document.getElementById('hud-yaw').innerText = deg + "Â°";

            // åº”ç”¨ç‰©ä½“
            if (swordGroup) {
                swordGroup.position.set(flight.x, flight.y, 0);
                swordGroup.rotation.set(0,0,0);
                swordGroup.rotateY(flight.yaw);
                swordGroup.rotateX(flight.pitch);
                swordGroup.rotateZ(flight.roll);
                swordGroup.position.y += Math.sin(Date.now()*0.002)*0.1;
            }

            // åœ°å½¢
            if (terrainMesh) {
                terrainMesh.material.uniforms.time.value += 0.01;
                terrainMesh.material.uniforms.altitude.value = flight.altitude;
                terrainMesh.rotation.z = flight.yaw;
            }

            // ç›¸æœº
            camera.position.x += (flight.x * 0.4 - camera.position.x) * 0.05;
            camera.position.y += (flight.y * 0.5 + 5 - camera.position.y) * 0.05;
            if(swordGroup) camera.lookAt(swordGroup.position);

            renderer.render(scene, camera);
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0]; if(!file)return;
            const url = URL.createObjectURL(file);
            new THREE.GLTFLoader().load(url, (gltf)=>{
                if(swordGroup) scene.remove(swordGroup); swordGroup = new THREE.Group();
                const m = gltf.scene;
                const b = new THREE.Box3().setFromObject(m); const s = b.getSize(new THREE.Vector3());
                const sc = 8.0/Math.max(s.x,s.y,s.z); m.scale.set(sc,sc,sc);
                m.rotation.y = Math.PI; b.setFromObject(m); m.position.sub(b.getCenter(new THREE.Vector3()));
                swordGroup.add(m); scene.add(swordGroup);
            });
        });
        window.resetSword = createSevenStarSword;
    </script>
</body>
</html>